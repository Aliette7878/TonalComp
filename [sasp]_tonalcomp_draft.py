# -*- coding: utf-8 -*-
"""[SASP] TonalComp draft.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kIBeaEjiaXXwvLbKBHoh1Hlkclv3Ze9i
"""

import numpy as np
import librosa
import librosa.display
import math, os
import matplotlib.pyplot as plt

#do we need these ??
import sklearn
from sklearn import svm, metrics
import math
import IPython.display as ipd
import scipy as sp
import seaborn as sn

import this         #just in case <3

"""# Reading"""

from google.colab import files

uploaded = files.upload()

#file_location = 'free-spoken-digit-dataset/recordings/'  #why is that still here ? x)
file_name = "359586__mtg__sax-tenor-a-minor.wav"
audio, Fs = librosa.load(file_name, sr=None)
print("Fs: ",Fs)

"""#Parameters"""

#User input:
#f_low = int(input("lowest frequency = "));
#f_high = int(input("highest frequency = ")); #bandwidth = [f_low, f_high]
f_low = 120; 

#Number of harmonics 
N_h = 8;

#Window type
Win_type = "hamming"
#Smoothness factor
L = 4;

#Frequency separation
f_low_2=f_low*(2**(1/12)); #f_low_2 is 1/2 tone above f_low
d_fmin = 6 # df>6Hz, otherwise Nfft is too high
d_f = max(d_fmin, int(f_low_2 - f_low)); #the user shouldn't be able to select d_f<100Hz

#Window length
#Depends on our sampling frequency and the desired frequency separation
Win_length = math.floor(L*Fs/d_f);

#Number of FFT samples
#N_fft should be at least the window's length, and should respect the JND criteria
N_fft = max(2**math.ceil(math.log2(Win_length)),2**math.ceil(math.log2(Fs/(2*3))));

#Hop ratio
Hop_ratio = 4;

#Hop length
Hop_length = int(Win_length / Hop_ratio);

#Number of frames
n_frames = math.floor((len(audio) - Win_length)/Hop_length) + 1;

print("d_f = "+ str(d_f) + " Hz")
print("window length = "+ str(Win_length))
print("N_fft = "+ str(N_fft))
print("hop length = "+ str(Hop_length))
print("n frames = "+ str(n_frames))
print("Audio length = " + str(len(audio)))

"""# STFT"""

X = np.abs(librosa.stft(
    audio,
    win_length=Win_length,
    window=Win_type,
    n_fft=N_fft,
    hop_length=Hop_length)
    )

X_db = librosa.amplitude_to_db(X, ref=np.max)

#Frequency spectrogram

plt.figure(figsize=(10, 4))
librosa.display.specshow((X_db),y_axis='log', x_axis='time')
#S_dB = librosa.power_to_db(S1, ref=np.max)
#librosa.display.specshow(S_dB, x_axis='time', y_axis='hz', sr=sr, fmax=4000)

plt.colorbar(format='%+2.0f dB')
plt.title('Frequency spectrogram')
plt.tight_layout()
plt.show()

"""# Peak location"""

Peak_loc = np.zeros(n_frames)
Peak_mag = np.zeros(n_frames)
# Peak_phase = np.zeros(n_frames)
#print("X_db shape :", X_db.shape())

# for i in range(n_frames):
#   Peak_mag[i] = np.amax(X_db[:,i])
#   Peak_loc[i] = i       # what ?? like frame 50, the peak is at freq 50 ? :o

for i in range(n_frames):
  Peak_loc[i] = np.argmax(X_db[:,i])
  Peak_mag[i] = X_db[int(Peak_loc[i]),i]  #np.argmax return float even though here it's always int.
  # if Peak_mag[i]< -15:      #just an idea to discard peak searching during silence (or low noise..)
  #   Peak_loc[i]=0

print("\n peak localisation : ",Peak_loc)

#printing the spectrum of one frame

plt.figure(figsize=(20, 15))

indexToFreq = Fs/(N_fft)        #explicit > implicit (line 2 of the Zen of Python)(am I a nerd ? :s)

#for frame nÂ°frameIndex
frameIndex = 148  # this one is cool because first harmo > fundamental

plt.plot(indexToFreq*np.arange(X_db[:1000,frameIndex].size), X_db[:1000,frameIndex]);
plt.plot(indexToFreq*Peak_loc[frameIndex], Peak_mag[frameIndex], 'X');
print(np.amax(X_db[:, frameIndex]));

X.shape, N_fft, audio.size/Hop_length

"""#Clement's part on peak finding"""

# Printing the max frequency through frames.

plt.figure(figsize=(15, 8))

indexToFreq = Fs/(N_fft)

plt.plot(np.arange(len(Peak_loc)),indexToFreq*Peak_loc, 'o');

# now let's find secondary peaks

def flattenMaxPeak(Xdb,maxPeakLoc):
  
  for frameIndex in range(n_frames):

    minFreq = int(maxPeakLoc[frameIndex])-int(maxPeakLoc[frameIndex]/16)
    maxFreq = int(maxPeakLoc[frameIndex])+int(maxPeakLoc[frameIndex]/16)
    for freqIndex in range(minFreq,maxFreq):
      Xdb[freqIndex,frameIndex] = -80

  return(Xdb)

X_db_step2 = flattenMaxPeak(np.copy(X_db),Peak_loc)   # we can now repeat the previous work on X_db_step2 to find the second peak.

plt.figure(figsize=(15, 8))
indexToFreq = Fs/(N_fft)
frameIndex = 148    # set to which one you want
plt.plot(indexToFreq*np.arange(X_db_step2[:1000,frameIndex].size), X_db_step2[:1000,frameIndex]);
plt.plot(indexToFreq*Peak_loc[frameIndex], Peak_mag[frameIndex], 'X');

# Now finding second max peak and printing the whole

Peak_loc_step2 = np.zeros(n_frames)
Peak_mag_step2 = np.zeros(n_frames)
print("X_db_step2 shape :",X_db_step2.shape)

for i in range(n_frames):
  Peak_loc_step2[i] = np.argmax(X_db_step2[:,i])
  Peak_mag_step2[i] = X_db_step2[int(Peak_loc_step2[i]),i]  #np.argmax return float even though here it's always int.


# Printing the 2 max frequency through frames.

plt.figure(figsize=(15, 8))
indexToFreq = Fs/(N_fft)

plt.plot(np.arange(len(Peak_loc)),indexToFreq*Peak_loc, 'o');
plt.plot(np.arange(len(Peak_loc_step2)),indexToFreq*Peak_loc_step2, 'x');

# Step 3 for Peak 3


X_db_step3 = flattenMaxPeak(np.copy(X_db_step2),Peak_loc_step2)   # we can now repeat the previous work on X_db_step2 to find the second peak.

plt.figure(figsize=(15, 8))
indexToFreq = Fs/(N_fft)
frameIndex = 45    # one mean stubborn
plt.plot(indexToFreq*np.arange(X_db_step3[:1000,frameIndex].size), X_db_step3[:1000,frameIndex]);

# Now finding third max peak and printing the whole

Peak_loc_step3 = np.zeros(n_frames)
Peak_mag_step3 = np.zeros(n_frames)
print("X_db_step3 shape :",X_db_step3.shape)

for i in range(n_frames):
  Peak_loc_step3[i] = np.argmax(X_db_step3[:,i])
  Peak_mag_step3[i] = X_db_step3[int(Peak_loc_step3[i]),i]  #np.argmax return float even though here it's always int.


# Printing the 2 max frequency through frames.

plt.figure(figsize=(15, 8))
indexToFreq = Fs/(N_fft)

plt.plot(np.arange(len(Peak_loc)),indexToFreq*Peak_loc, 'o');
plt.plot(np.arange(len(Peak_loc_step2)),indexToFreq*Peak_loc_step2, 'x');
plt.plot(np.arange(len(Peak_loc_step3)),indexToFreq*Peak_loc_step3, 'v');

"""etc etc... but I think using this method, 5 peaks will be more than enough. now I gotta figure a more efficient way to get these peaks, because for now this is a bit complex... Anyways this was just to work on this way of thinking... in case of no-fundamental we can add a layer working on GCD (great common divisor)

#Handling errors:
- if M > N
"""